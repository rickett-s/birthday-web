<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子文字展示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            cursor: none;
        }

        body.ready {
            cursor: default;
        }

        .canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .title {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 480px) {
            .title {
                font-size: 18px;
                top: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="title">粒子文字展示</div>
    <canvas class="canvas"></canvas>

    <script>
        // 全局命名空间
        var S = {
            init: function() {
                S.Drawing.init('.canvas');
                document.body.classList.add('ready');
                S.GradientBackground.init();
                
                // 预设的文字序列
                var textSequence = [
                    '欢迎',
                    '光临',
                    '2024',
                    '新年',
                    '快乐',
                    '阖家',
                    '幸福',
                    '祝愿',
                    '美好',
                    '未来'
                ];
                
                S.TextSequence.start(textSequence);
            }
        };

        // 高级渐变动态背景
        S.GradientBackground = (function() {
            var canvas, ctx, animationId;
            var time = 0;
            
            function createGradient() {
                var gradient = ctx.createLinearGradient(0, 0, window.innerWidth, window.innerHeight);
                var colors = [
                    `hsl(${(time * 0.1) % 360}, 70%, 60%)`,
                    `hsl(${(time * 0.1 + 60) % 360}, 70%, 65%)`,
                    `hsl(${(time * 0.1 + 120) % 360}, 70%, 70%)`,
                    `hsl(${(time * 0.1 + 180) % 360}, 70%, 75%)`,
                    `hsl(${(time * 0.1 + 240) % 360}, 70%, 80%)`,
                    `hsl(${(time * 0.1 + 300) % 360}, 70%, 85%)`
                ];
                
                colors.forEach((color, i) => {
                    gradient.addColorStop(i / 5, color);
                });
                
                return gradient;
            }
            
            function drawAnimatedGrid() {
                ctx.fillStyle = createGradient();
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 添加动态网格效果
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                var gridSize = 80;
                for (var x = 0; x < canvas.width; x += gridSize) {
                    var alpha = Math.sin((x + time * 2) * 0.01) * 0.3 + 0.2;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (var y = 0; y < canvas.height; y += gridSize) {
                    var alpha = Math.sin((y + time * 2) * 0.01) * 0.3 + 0.2;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            }
            
            function drawFloatingParticles() {
                var particleCount = 50;
                for (var i = 0; i < particleCount; i++) {
                    var x = (i * 123.456) % canvas.width;
                    var y = (i * 654.321 + Math.sin(time * 0.005 + i)) * canvas.height * 0.3;
                    var size = Math.sin(time * 0.01 + i * 0.1) * 3 + 2;
                    var alpha = Math.sin(time * 0.008 + i * 0.05) * 0.5 + 0.5;
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            function animate() {
                time++;
                drawAnimatedGrid();
                drawFloatingParticles();
                animationId = requestAnimationFrame(animate);
            }
            
            return {
                init: function() {
                    canvas = document.querySelector('.canvas');
                    ctx = canvas.getContext('2d');
                    
                    function resize() {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }
                    resize();
                    window.addEventListener('resize', resize);
                    
                    animate();
                }
            };
        })();

        // 文字序列控制
        S.TextSequence = (function() {
            var currentIndex = 0;
            var textSequence = [];
            var interval;
            
            function showNextText() {
                if (currentIndex < textSequence.length) {
                    var text = textSequence[currentIndex];
                    S.Shape.switchShape(S.ShapeBuilder.letter(text));
                    currentIndex++;
                    
                    // 最后一个文字显示时间长一点
                    var delay = currentIndex === textSequence.length ? 5000 : 3000;
                    interval = setTimeout(showNextText, delay);
                } else {
                    // 循环播放
                    currentIndex = 0;
                    showNextText();
                }
            }
            
            return {
                start: function(sequence) {
                    textSequence = sequence;
                    currentIndex = 0;
                    showNextText();
                }
            };
        })();

        // 绘制模块
        S.Drawing = (function() {
            var canvas, context, renderFn,
                requestFrame = window.requestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              window.mozRequestAnimationFrame ||
                              function(callback) {
                                  window.setTimeout(callback, 1000/60);
                              };

            return {
                init: function(el) {
                    canvas = document.querySelector(el);
                    context = canvas.getContext('2d');
                    this.adjustCanvas();

                    window.addEventListener('resize', function(e) {
                        S.Drawing.adjustCanvas();
                    });
                },

                loop: function(fn) {
                    renderFn = !renderFn ? fn : renderFn;
                    renderFn(); // 不清除背景，让背景特效保持
                    requestFrame.call(window, this.loop.bind(this));
                },

                adjustCanvas: function() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                },

                getArea: function() {
                    return { w: canvas.width, h: canvas.height };
                },

                drawCircle: function(p, c) {
                    context.fillStyle = c.render();
                    context.beginPath();
                    context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
                    context.closePath();
                    context.fill();
                }
            }
        })();

        // 点类
        S.Point = function(args) {
            this.x = args.x;
            this.y = args.y;
            this.z = args.z;
            this.a = args.a;
            this.h = args.h;
        };

        // 颜色类
        S.Color = function(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        };

        S.Color.prototype = {
            render: function() {
                return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')';
            }
        };

        // 粒子类
        S.Dot = function(x, y) {
            this.p = new S.Point({
                x: x,
                y: y,
                z: 4,
                a: 1,
                h: 0
            });

            this.e = 0.08;
            this.s = true;
            this.c = new S.Color(255, 255, 255, this.p.a);
            this.t = this.clone();
            this.q = [];
        };

        S.Dot.prototype = {
            clone: function() {
                return new S.Point({
                    x: this.p.x,
                    y: this.p.y,
                    z: this.p.z,
                    a: this.p.a,
                    h: this.p.h
                });
            },

            _draw: function() {
                this.c.a = this.p.a;
                S.Drawing.drawCircle(this.p, this.c);
            },

            _moveTowards: function(n) {
                var details = this.distanceTo(n, true),
                    dx = details[0],
                    dy = details[1],
                    d = details[2],
                    e = this.e * d;

                if(this.p.h === -1) {
                    this.p.x = n.x;
                    this.p.y = n.y;
                    return true;
                }

                if(d > 1) {
                    this.p.x -= ((dx / d) * e);
                    this.p.y -= ((dy / d) * e);
                } else {
                    if(this.p.h > 0) {
                        this.p.h--;
                    } else {
                        return true;
                    }
                }

                return false;
            },

            _update: function() {
                if(this._moveTowards(this.t)) {
                    var p = this.q.shift();

                    if(p) {
                        this.t.x = p.x || this.p.x;
                        this.t.y = p.y || this.p.y;
                        this.t.z = p.z || this.p.z;
                        this.t.a = p.a || this.p.a;
                        this.p.h = p.h || 0;
                    } else {
                        if(this.s) {
                            this.p.x -= Math.sin(Math.random() * 3.142);
                            this.p.y -= Math.sin(Math.random() * 3.142);
                        } else {
                            this.move(new S.Point({
                                x: this.p.x + (Math.random() * 50) - 25,
                                y: this.p.y + (Math.random() * 50) - 25,
                            }));
                        }
                    }
                }

                var d = this.p.a - this.t.a;
                this.p.a = Math.max(0.1, this.p.a - (d * 0.05));
                d = this.p.z - this.t.z;
                this.p.z = Math.max(1, this.p.z - (d * 0.05));
            },

            distanceTo: function(n, details) {
                var dx = this.p.x - n.x,
                    dy = this.p.y - n.y,
                    d = Math.sqrt(dx * dx + dy * dy);
                return details ? [dx, dy, d] : d;
            },

            move: function(p, avoidStatic) {
                if(!avoidStatic || (avoidStatic && this.distanceTo(p) > 1)) {
                    this.q.push(p);
                }
            },

            render: function() {
                this._update();
                this._draw();
            }
        };

        // 形状构建器
        S.ShapeBuilder = (function() {
            var gap = 12,
                shapeCanvas = document.createElement('canvas'),
                shapeContext = shapeCanvas.getContext('2d'),
                fontSize = 500,
                fontFamily = 'Arial, sans-serif';

            function fit() {
                shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap;
                shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap;
                shapeContext.fillStyle = 'white';
                shapeContext.textBaseline = 'middle';
                shapeContext.textAlign = 'center';
            }

            function processCanvas() {
                var pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data,
                    dots = [],
                    x = 0, y = 0,
                    w = 0, h = 0,
                    fx = shapeCanvas.width,
                    fy = shapeCanvas.height;

                for(var p = 0; p < pixels.length; p += (4 * gap)) {
                    if(pixels[p + 3] > 128) {
                        dots.push(new S.Point({
                            x: x,
                            y: y
                        }));

                        w = x > w ? x : w;
                        h = y > h ? y : h;
                        fx = x < fx ? x : fx;
                        fy = y < fy ? y : fy;
                    }

                    x += gap;
                    if(x >= shapeCanvas.width) {
                        x = 0;
                        y += gap;
                        p += gap * 4 * shapeCanvas.width;
                    }
                }

                return { dots: dots, w: w + fx, h: h + fy };
            }

            function setFontSize(s) {
                shapeContext.font = 'bold ' + s + 'px ' + fontFamily;
            }

            function init() {
                fit();
                window.addEventListener('resize', fit);
            }

            init();

            return {
                letter: function(l) {
                    var s = 0;

                    setFontSize(fontSize);
                    s = Math.min(fontSize,
                        (shapeCanvas.width / shapeContext.measureText(l).width) * 0.8 * fontSize,
                        shapeCanvas.height * 0.4);
                    setFontSize(s);

                    shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
                    shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);

                    return processCanvas();
                }
            };
        })();

        // 形状模块
        S.Shape = (function() {
            var dots = [],
                width = 0,
                height = 0,
                cx = 0,
                cy = 0;

            function compensate() {
                var a = S.Drawing.getArea();
                cx = a.w / 2 - width / 2;
                cy = a.h / 2 - height / 2;
            }

            return {
                switchShape: function(n, fast) {
                    var size, a = S.Drawing.getArea();

                    width = n.w;
                    height = n.h;
                    compensate();

                    if(n.dots.length > dots.length) {
                        size = n.dots.length - dots.length;
                        for(var d = 1; d <= size; d++) {
                            dots.push(new S.Dot(a.w / 2, a.h / 2));
                        }
                    }

                    var d = 0, i = 0;
                    while(n.dots.length > 0) {
                        i = Math.floor(Math.random() * n.dots.length);
                        dots[d].e = fast ? 0.25 : (dots[d].s ? 0.14 : 0.11);

                        if(dots[d].s) {
                            dots[d].move(new S.Point({
                                z: Math.random() * 20 + 10,
                                a: Math.random(),
                                h: 18
                            }));
                        } else {
                            dots[d].move(new S.Point({
                                z: Math.random() * 5 + 5,
                                h: fast ? 18 : 30
                            }));
                        }

                        dots[d].s = true;
                        dots[d].move(new S.Point({
                            x: n.dots[i].x + cx,
                            y: n.dots[i].y + cy,
                            a: 1,
                            z: 4,
                            h: 0
                        }));

                        n.dots = n.dots.slice(0, i).concat(n.dots.slice(i + 1));
                        d++;
                    }

                    for(var i = d; i < dots.length; i++) {
                        if(dots[i].s) {
                            dots[i].move(new S.Point({
                                z: Math.random() * 20 + 10,
                                a: Math.random(),
                                h: 20
                            }));
                            dots[i].s = false;
                            dots[i].e = 0.04;
                            dots[i].move(new S.Point({
                                x: Math.random() * a.w,
                                y: Math.random() * a.h,
                                a: 0.3,
                                z: Math.random() * 4,
                                h: 0
                            }));
                        }
                    }
                },

                render: function() {
                    for(var d = 0; d < dots.length; d++) {
                        dots[d].render();
                    }
                }
            }
        })();

        // 初始化动画循环
        S.Drawing.loop(S.Shape.render);

        // 页面加载完成后启动
        window.addEventListener('load', function() {
            S.init();
        });
    </script>
</body>
</html>